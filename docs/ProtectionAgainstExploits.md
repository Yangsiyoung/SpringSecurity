Protection Against Exploits
============================
Spring Security 는 일반적인 악의적인 행위에 대한 방지책을 제공한다.  
일반적으로 Spring Security 에서 기본적으로 제공하는 보안정책은 활성화 되어있다.  
Spring Security 가 제공하는 다양한 악의적인 행위에 대한 자세한 설명이 아래에  
기재되어있다.  

# 1. Cross Site Request Forgery (CSRF)
Spring 은 [**Cross Site Request Forgery**](https://en.wikipedia.org/wiki/Cross-site_request_forgery) 공격에 대한 전반적인  
방지책을 지원한다.  

* [**What is a CSRF Attack?**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-explained)
* [**Protecting Against CSRF Attacks**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection)
* [**CSRF Considerations**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-considerations)

_이 문서에서는 CSRF 에 대한 일반적인 부분에 대해서 다루며,  
servlet 그리고 WebFlux 기반의 어플리케이션에 대한 CSRF 방지에 대한 자세한 정보는  
링크를 따라가서 보길 바란다._  

* [**servlet 기반 어플리케이션**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-csrf)
* [**WebFlux 기반 어플리케이션**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#webflux-csrf)

# 2. What is a CSRF Attack?
CSRF 를 이해하기 가장 쉬운 방법은 구체적인 예시를 보는 것 이다.  

우리의 은행 웹사이트는 현재 로그인한 유저가 다른 은행의 계좌로 송금하는 폼을 제공한다고 가정해보자.  
예를들어 송금하는 폼은 아래와 같이 생겼다. 

* Transfer form

```
<form method="post"
    action="/transfer">
<input type="text"
    name="amount"/>
<input type="text"
    name="routingNumber"/>
<input type="text"
    name="account"/>
<input type="submit"
    value="Transfer"/>
</form>
```
그리고 이에대한 HTTP Request 는 아래와 같을 것 이다.

* Transfer HTTP request
```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
```

이제 당신이 은행사이트에 로그인을 하고 로그아웃을 하지 않은 상태에서 악성 웹사이트를 방문했으며,    
악성 웹사이트는 아래와같은 폼을 포함하고 있다고 해보자.  
(악성 웹사이트는 버튼을 클릭하면 돈을 벌수있게 해준다고 현혹하는 사이트)  

* Evil transfer form
```
<form method="post"
    action="https://bank.example.com/transfer">
<input type="hidden"
    name="amount"
    value="100.00"/>
<input type="hidden"
    name="routingNumber"
    value="evilsRoutingNumber"/>
<input type="hidden"
    name="account"
    value="evilsAccountNumber"/>
<input type="submit"
    value="Win Money!"/>
</form>
```

당신은 돈을 벌고싶기때문에 submit 버튼을 클릭할 것 이다.  
이 과정에서 당신은 악의적인 유저에게 $100 송금을 의도치 않게 하게 될 것이다.  
이는 악성 웹사이트가 당신의 은행 사이트 쿠키를 직접 보진 못하지만 은행 사이트 쿠키는 여전히 Request 와 함께 보내질 수 있기때문에  
발생한다.

최악의 경우 이러한 프로세스가 JavaScript 를 이용해서 자동화되었을 수 있다.  
이 것이 의미하는 바는 당신이 버튼을 클릭하지 않아도 악성 웹사이트를 방문하는 순간  
자동으로 수행될 수 있다.  

게다가 [**XSS 공격**](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS))을 받은 올바른 사이트를 방문할 떄에도 쉽게 발생할 수 있다.  
자 그럼 이제 우리는 어떻게 우리의 유저를 이런 공격들에 대해서 보호할 수 있을까?  

# 3. Protecting Against CSRF Attacks
CSRF 공격이 가능한 이유는 희생자의 웹사이트 HTTP Request 와 희생자가 방문한 악의적인 웹사이트의  
HTTP Request 의 모양이 일치하기 때문이다. 이것은 은행 웹사이트에서 오는 Request 는 허락하고  
악의적인 웹사이트에서 오는 Request 는 거부하는 방법이 없다는 뜻 이다.  

CSRF 공격을 막기위해서 Request 안에 어떤 것이 포함되어 있어서 악의적인 웹사이트에서는 포함할 수 없어서  
두 Request 에 대한 구별을 가능하게 하는 것이 필요하다.  

Spring 은 CSRF 공격에 대한 방지책으로 두가지 메커니즘을 제공한다.  
* The [**Synchronizer Token Pattern**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection-stp)
* Specifying the [**SameSite Attribute**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection-ssa) on your session cookie

# 4. Safe Methods Must be Idempotent
위의 두가지 메커니즘이 작동하려면, 어플리케이션은 "safe" HTTP 메서드들이 멱등성이라는 것을 보장해야한다.  
(멱등성 : 연산을 여러 번 적용하더라도 결과값이 달라지지 않음)
이 뜻은 GET, HEAD, OPTIONS 그리고 TRACE 와 같은 HTTP 메서드의 Request 는 어플리케이션의 상태를  
변경해서는 안된다는 것 이다.
(GET, HEAD, OPTIONS 그리고 TRACE 와 같은 HTTP 메서드는 유저 데이터를 변경하는 등의 상태 변경  
행위를 하면 안된다는 뜻)

# Synchronizer Token Pattern
우세하고 가장 포괄적인 CSRF 공격에 대한 방어기법은 Synchronizer Token Pattern 을 사용하는 것 이다.  
이 방법은 우리의 session cookie 외에 HTTP Request 에 CSRF token 이라 불리는  
랜덤으로 생성된 보안 값이 존재해야 한다는 것을 보장하는 것 입니다.

HTTP Request 가 오면(Form 에서 submit 버튼을 누르는 등), 서버는 예상하는 CSRF token 을 찾고  
실제로 HTTP Request 에 담겨온 CSRF token 값이 기대하는 CSRF token 값과 일치하는지 확인한다.  
만약에 일치하지 않는다면 HTTP Request 를 거부한다.

여기서 중요한 점은 실제 CSRF token 은 브라우저에 의해서 자동으로 포함되지 않는  
HTTP Request 요소여야 한다는 것 이다. 예를들어 HTTP Header 나 HTTP Parameter 에 CSRF token 을 담으면  
CSRF 공격을 방지할 수 있다. CSRF token 을 쿠키에 심으면 안된다. 왜냐면 쿠키는 브라우저에 의해서  
HTTP Request 를 보낼 때 자동으로 포함되기 때문이다.  
(은행 웹사이트에 유저가 로그인했고, 그 상태에서 다른 악성 웹사이트를 방문했다.  
 다른 악성 웹사이트에서 마치 해당 유저인 것처럼 요청을 보낼 것이다.
 요청을 하는 곳이 악성 웹사이트이니까 유저의 은행 쿠키는 악성 웹사이트에서  
 은행으로 요청을 보내서 마치 해당 유저가 보낸 것처럼 행동할 수 있다.
 
 하지만 송금 폼을 만들때마다 임의의 값을 생성하고 송금 폼에 해당 값을 hidden 으로 넘겨서
 해당 세션만이, 즉 해당 유저만이 그 값을 사용할 수 있다면? 좀더 안전해지겠지??
 지금은 그렇게 이해하면된다.)
 
 

 