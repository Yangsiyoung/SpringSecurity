Protection Against Exploits
============================
Spring Security 는 일반적인 악의적인 행위에 대한 방지책을 제공한다.  
일반적으로 Spring Security 에서 기본적으로 제공하는 보안정책은 활성화 되어있다.  
Spring Security 가 제공하는 다양한 악의적인 행위에 대한 자세한 설명이 아래에  
기재되어있다.  

# 1. Cross Site Request Forgery (CSRF)
Spring 은 [**Cross Site Request Forgery**](https://en.wikipedia.org/wiki/Cross-site_request_forgery) 공격에 대한 전반적인  
방지책을 지원한다.  

* [**What is a CSRF Attack?**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-explained)
* [**Protecting Against CSRF Attacks**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection)
* [**CSRF Considerations**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-considerations)

_이 문서에서는 CSRF 에 대한 일반적인 부분에 대해서 다루며,  
servlet 그리고 WebFlux 기반의 어플리케이션에 대한 CSRF 방지에 대한 자세한 정보는  
링크를 따라가서 보길 바란다._  

* [**servlet 기반 어플리케이션**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-csrf)
* [**WebFlux 기반 어플리케이션**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#webflux-csrf)

# 2. What is a CSRF Attack?
CSRF 를 이해하기 가장 쉬운 방법은 구체적인 예시를 보는 것 이다.  

우리의 은행 웹사이트는 현재 로그인한 유저가 다른 은행의 계좌로 송금하는 폼을 제공한다고 가정해보자.  
예를들어 송금하는 폼은 아래와 같이 생겼다. 

* Transfer form

```
<form method="post"
    action="/transfer">
<input type="text"
    name="amount"/>
<input type="text"
    name="routingNumber"/>
<input type="text"
    name="account"/>
<input type="submit"
    value="Transfer"/>
</form>
```
그리고 이에대한 HTTP Request 는 아래와 같을 것 이다.

* Transfer HTTP request
```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
```

이제 당신이 은행사이트에 로그인을 하고 로그아웃을 하지 않은 상태에서 악성 웹사이트를 방문했으며,    
악성 웹사이트는 아래와같은 폼을 포함하고 있다고 해보자.  
(악성 웹사이트는 버튼을 클릭하면 돈을 벌수있게 해준다고 현혹하는 사이트)  

* Evil transfer form
```
<form method="post"
    action="https://bank.example.com/transfer">
<input type="hidden"
    name="amount"
    value="100.00"/>
<input type="hidden"
    name="routingNumber"
    value="evilsRoutingNumber"/>
<input type="hidden"
    name="account"
    value="evilsAccountNumber"/>
<input type="submit"
    value="Win Money!"/>
</form>
```

당신은 돈을 벌고싶기때문에 submit 버튼을 클릭할 것 이다.  
이 과정에서 당신은 악의적인 유저에게 $100 송금을 의도치 않게 하게 될 것이다.  
이는 악성 웹사이트가 당신의 은행 사이트 쿠키를 직접 보진 못하지만 은행 사이트 쿠키는 여전히 Request 와 함께 보내질 수 있기때문에  
발생한다.

최악의 경우 이러한 프로세스가 JavaScript 를 이용해서 자동화되었을 수 있다.  
이 것이 의미하는 바는 당신이 버튼을 클릭하지 않아도 악성 웹사이트를 방문하는 순간  
자동으로 수행될 수 있다.  

게다가 [**XSS 공격**](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS))을 받은 올바른 사이트를 방문할 떄에도 쉽게 발생할 수 있다.  
자 그럼 이제 우리는 어떻게 우리의 유저를 이런 공격들에 대해서 보호할 수 있을까?  

# 3. Protecting Against CSRF Attacks
CSRF 공격이 가능한 이유는 희생자의 웹사이트 HTTP Request 와 희생자가 방문한 악의적인 웹사이트의  
HTTP Request 의 모양이 일치하기 때문이다. 이것은 은행 웹사이트에서 오는 Request 는 허락하고  
악의적인 웹사이트에서 오는 Request 는 거부하는 방법이 없다는 뜻 이다.  

CSRF 공격을 막기위해서 Request 안에 어떤 것이 포함되어 있어서 악의적인 웹사이트에서는 포함할 수 없어서  
두 Request 에 대한 구별을 가능하게 하는 것이 필요하다.  

Spring 은 CSRF 공격에 대한 방지책으로 두가지 메커니즘을 제공한다.  
* The [**Synchronizer Token Pattern**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection-stp)
* Specifying the [**SameSite Attribute**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection-ssa) on your session cookie

# 4. Safe Methods Must be Idempotent
위의 두가지 메커니즘이 작동하려면, 어플리케이션은 "safe" HTTP 메서드들이 멱등성이라는 것을 보장해야한다.  
(멱등성 : 연산을 여러 번 적용하더라도 결과값이 달라지지 않음)
이 뜻은 GET, HEAD, OPTIONS 그리고 TRACE 와 같은 HTTP 메서드의 Request 는 어플리케이션의 상태를  
변경해서는 안된다는 것 이다.
(GET, HEAD, OPTIONS 그리고 TRACE 와 같은 HTTP 메서드는 유저 데이터를 변경하는 등의 상태 변경  
행위를 하면 안된다는 뜻)

# 5. Synchronizer Token Pattern
우세하고 가장 포괄적인 CSRF 공격에 대한 방어기법은 Synchronizer Token Pattern 을 사용하는 것 이다.  
이 방법은 우리의 session cookie 외에 HTTP Request 에 CSRF token 이라 불리는  
랜덤으로 생성된 보안 값이 존재해야 한다는 것을 보장하는 것 입니다.

HTTP Request 가 오면(Form 에서 submit 버튼을 누르는 등), 서버는 예상하는 CSRF token 을 찾고  
실제로 HTTP Request 에 담겨온 CSRF token 값이 기대하는 CSRF token 값과 일치하는지 확인한다.  
만약에 일치하지 않는다면 HTTP Request 를 거부한다.

여기서 중요한 점은 실제 CSRF token 은 브라우저에 의해서 자동으로 포함되지 않는  
HTTP Request 요소여야 한다는 것 이다. 예를들어 HTTP Header 나 HTTP Parameter 에 CSRF token 을 담으면  
CSRF 공격을 방지할 수 있다. CSRF token 을 쿠키에 심으면 안된다. 왜냐면 쿠키는 브라우저에 의해서  
HTTP Request 를 보낼 때 자동으로 포함되기 때문이다.  
(은행 웹사이트에 유저가 로그인했고, 그 상태에서 다른 악성 웹사이트를 방문했다.  
 다른 악성 웹사이트에서 마치 해당 유저인 것처럼 요청을 보낼 것이다.
 요청을 하는 곳이 악성 웹사이트이니까 유저의 은행 쿠키는 악성 웹사이트에서  
 은행으로 요청을 보내서 마치 해당 유저가 보낸 것처럼 행동할 수 있다.
 
 하지만 송금 폼을 만들때마다 임의의 값을 생성하고 송금 폼에 해당 값을 hidden 으로 넘겨서
 해당 세션만이, 즉 해당 유저만이 그 값을 사용할 수 있다면? 좀더 안전해지겠지??
 지금은 그렇게 이해하면된다.)  
 
우리는 어플리케이션의 상태를 변경하는 모든 HTTP Request 에 대해서 CSRF token 을 요구한다는 사실에 안심할 수 있다.  
이 과정이 정상적으로 작동하려면, 우리의 어플리케이션이 safe HTTP 메서드들이 멱등성을 지닌다는 것을 보장해야한다.  
우리는 외부 사이트로부터 우리 사이트로 들어오는 링크를 허용하기 떄문에 이런 방식은 우리 서비스의 사용성을 높여준다.  
게다가 우리는 CSRF Token 이 노출되는 HTTP GET 메서드에는 CSRF Token 을 사용하지 않는다.  

이제 Synchronizer Token Pattern 을 사용하는 예제를 보자.  
CSRF token 이 _csrf 라는 이름의 HTTP Parameter 로 사용된다고 가정하자.  
우리의 어플리케이션에서 송금 폼은 아래와 같을 것 이다.

* Synchronizer Token Form
```
<form method="post"
    action="/transfer">
<input type="hidden"
    name="_csrf"
    value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
<input type="text"
    name="amount"/>
<input type="text"
    name="routingNumber"/>
<input type="hidden"
    name="account"/>
<input type="submit"
    value="Transfer"/>
</form>
```

이 폼은 CSRF token 의 값을 hidden type input 으로 포함하고 있다.  
외부 사이트에서는 Same Origin 정책 때문에 외부사이트에서는 이 폼에 있는 CSRF token 을  
읽을 수 없다.  

송금을 하는 HTTP Request 는 아래와 같이 생겼다.  

* Synchronizer Token request
```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876&_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721
```

_csrf Parameter 에 보안 랜덤 값이 HTTP Request 에 포함되어 있다는 것을 알 수 있다.  
악성 웹사이트는 _csrf Parameter 에 올바른 값을 제공하지 못하며 따라서 서버에서 실제 CSRF token 값과  
기대하는 CSRF token 값의 비교를 통해서 송금이 실패하게 된다.  

# 6. SameSite Attribute
CSRF 공격에 대한 신흥세력은 Cookie 의 SameSite Attribute 를 활용하는 것 이다.  
서버는 자신의 사이트 외의 다른 사이트에서 자신의 사이트가 발급한 쿠키를 HTTP Request 에 담아서 보내지 못하도록  
Cookie 를 발급하는 시점에 SameSite Attribute 를 설정할 수 있다.  

Spring Security 는 session cookie 의 생성에 대한 부분은 직접적으로 컨트롤하지 않는다,  
따라서 SameSite Attribute 설정애 대한 지원을 하지 않는다.  

[**Spring Session**](https://spring.io/projects/spring-session) 은 Servlet 기반 어플리케이션의  
SameSite Attribute 를 설정하도록 지원한다.  

Spring Framework 의 [**CookieWebSessionIdResolver**](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html) 는  
WebFlux 기반 어플리케이션의 SameSite Attribute 를 설정하도록 지원한다.  

아래는 SameSite Attribute 가 설정된 HTTP Response Header 의 예제다.

* SameSite HTTP response
```
Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
```  

SameSite Attribute 의 올바른 값은 아래 2가지이다.

* Strict  
이 속성이 지정된 경우 같은 사이트에서 오는 모든 요청에 대해서만 쿠키를 허용한다.  
그렇지 않으면 쿠키가 HTTP 요청에 포함되지 않는다.

* Lax  
동일한 사이트에서 오는 요청에 대해서만 쿠키를 허용하거나 사용자가 직접 주소창에 입력하는 top-level navigations  
이며 멱등성을 가지고 있는 HTTP 메서드(EX. GET)일 때 쿠키를 허용하겠다는 것 이다.  
그렇지 않으면 쿠키가 HTTP 요청에 포함되지 않는다.  

이제 초기 송금 폼을 보며 SameSite 가 어떻게 CSRF 공격을 방지하는지 알아보겠다.  
은행 어플리케이션은 session cookie 에 SameSite Attribute 를 설정함으로써  
CSRF 공격을 막을 수 있다.    

* Transfer form
```
<form method="post"
    action="/transfer">
<input type="text"
    name="amount"/>
<input type="text"
    name="routingNumber"/>
<input type="text"
    name="account"/>
<input type="submit"
    value="Transfer"/>
</form>
```

session cookie 에 SameSite Attribute 가 설정되어 있다면,  
브라우저는 은행 웹사이트로 부터 오는 모든 HTTP Request 에 대해 JSESSIONID cookie 를  
함께 보낼 것 이다.

하지만 악성 웹사이트(다른 도메인의 웹사이트)에서 오는 HTTP Request 에 대해서  
더이상 JSESSIONID cookie 를 함께 보내지 않을 것 이다.  
이제 악성 웹사이트(다른 도메인의 웹사이트)에서 오는 요청에는 더이상 session 이 없으므로,  
어플리케이션은 CSRF 공격을 방지할 수 있다.  

우리가 CSRF 공격을 방지하기 위해 SameSite Attribute 를 사용할 때  
몇가지 중요하게 [**고려할 점**](https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-5) 이 있다.  
(XSS 공격을 받는 등의 문제가 발생하는 경우를 말하는 듯)  

SameSite Attribute 를 Strict 로 설정하면 강력한 방어가 되겠지만,  
유저들의 혼란을 야기할 수 있다. 예를들어 한 유저가 https://social.example.com 이라는  
소셜 미디어 사이트에 로그인을 한 상태라고하자. 그리고 유저는 https://email.example.org 이라는  
사이트에서 이메일을 받았고 그 이메일에는 로그인한 상태의 소셜 미디어 사이트로 이동하는 링크가  
포함되어 있다고 하자. 만약 유저가 해당 링크를 클릭하면 해당 소셜 미디어 사이트에 이미 로그인 된 상태이므로  
로그인 되는 상태를 기대했을 것 이지만, SameSite Attribute 가 Strict 로 되어 있기 때문에  
https://email.example.org -> https://social.example.com 접근이므로  
기존에 소셜 미디어 사이트(https://social.example.com) 에서 로그인하여 발급받은 cookie 를  
전송하지 못하여 로그인하지 않은 상태로 보일 것 이다.
(예를들어 페이스북에서 로그인하고, Gmail 들어가서 온 메일 중 페이스북으로 이동하는 링크의  
 메일을 열어 Gmail -> 페이스북으로 이동하는 링크 클릭했는데 페이스북 비로그인 상태로 연결이 된 것)  
 
_우리는 CSRF 공격에 대한 방어책인 SameSite 의 가용성을 높이기 위해 [**gh-7537**](https://github.com/spring-projects/spring-security/issues/7537) 을
구현하여 사용할 수 도 있다._

SameSite Attribute 를 사용하기 위해서 고려해야할 또다른 사항은, 브라우저가 SameSite Attribute 를  
지원해야한다는 점 이다. 대부분의 현대 브라우저들은 [**SameSite Attribute 를 지원**](https://developer.mozilla.org/en-US/docs/Web/HTTP/headers/Set-Cookie#Browser_compatibility) 하고 있다.  
하지만 예전 브라우저들은 여전히 사용할 수 없다.  

이러한 이유로 SameSite Attribute 는 CSRF 공격 방지를 위한 단일 전략이 아닌 추가 전략으로 사용할 것을  
권장한다.  




 


 

# 7. When to use CSRF protection
언제 CSRF 방어를 해야할까? 우리는 일반적인 유저들이 이용하는 브라우저를 통해 
요청되는 모든 Request 에 대해서 적용을 할 것을 권장한다.  
만약 당신이 브라우저 없이 동작하는 서비스(Native Mobile - API 서버 등)를 개발하고 있다면  
CSRF 방어를 비활성화 해도 된다.  
(CSRF 는 쿠키를 도용해서 동작하는 것 이니까.)

# 8. CSRF protection and JSON
일반적인 질문중 하나가 "자바스크립트에서 만들어지는 JSON Request 에 대해서도 방어를 해야합니까?" 이다.  
간단한 대답은 "때에 따라 다르다." 이다. 하지만 JSON Request 에 영향을 미치는 CSRF 공격이 있을 수 있기  
때문에 조심해야한다. 예를들어 악의적인 사용자는 [**JSON 을 활용한 CSRF 공격**](http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html) 을 만들어 낼 수 있다.  

* CSRF with JSON form
```
<form action="https://bank.example.com/transfer" method="post" enctype="text/plain">
    <input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
    <input type="submit"
        value="Win Money!"/>
</form>
```

위와 같은 폼을 활용해 만들어지는 악의적인 사용자(사이트)로부터의 JSON 구조는 아래와 같이 만들어진다.  

* CSRF with JSON request
```
{ "amount": 100,
"routingNumber": "evilsRoutingNumber",
"account": "evilsAccountNumber",
"ignore_me": "=test"
}
```

어플리케이션이 Content-Type 을 검사하지 않는다면, 위와 같은 방법으로 인해  
CSRF 위험에 노출된다. 설정에 따라 Spring MVC 어플리케이션은 Content-Type 을 검사하더라도  
.json 으로 끝나는 URL 등을 사용함으로써 여전히 CSRF 위험에 노출된다.  

* CSRF with JSON Spring MVC form
```
<form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain">
    <input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
    <input type="submit"
        value="Win Money!"/>
</form>
```

# 9. CSRF and Stateless Browser Applications
나의 어플리케이션이 Stateless 라면 어떻게 될까? Stateless 라고 해서 반드시 보호받고 있는 건  
아니다. 사실 만약 한 유저가 브라우저에서 어떠한 행동도 취하지 않더라도 CSRF 공격에 여전히 취약할 수 있다.  

예를들어 한 어플리케이션이 JSESSIONID 대신 인증관련 상태를 담고 있는 커스텀 cookie 를 사용한다고 가정해보자.  
CSRF 공격이 발생하면 커스텀 cookie 는 이전 예제에서 봤듯 JSESSIONID cookie 처럼 같은 방식으로  
Request 에 포함되어 전송된다. 어플리케이션은 CSRF 공격에 취약해지는 것 이다.  

기본적인 인증(Username And Password 인증방식)을 사용하는 어플리케이션은 CSRF 공격에 취약하다.  
이전 예제에서 JSESSIONID cookie 가 Request 에 포함되어 전송되듯 브라우저는 Username 과 Password 를  
Request 에 포함하여 전송하기 때문이다.  


# 10. CSRF Considerations
CSRF 공격에 대한 방지법을 구현하기 위해 몇가지 고려사항이 있다.

## Logging In
[**로그인 위조**](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests) 에 대한 방지를 위해 CSRF 공격에 대한 대비가 되어있어야한다.  
악의적인 유저가 CSRF 피해자의 민감한 정보에 접근할 수 없도록 로그인 위조에 대한 처리가 필요하다.  
CSRF 공격을 통한 로그인 위조는 아래의 과정을 수행한다.  

* 악의적인 유저는 CSRF 를 통해 악의적인 유저의 계정으로 로그인을 수행한다.  
  이제 CSRF 의 피해자는 악의적인 유저의 계정으로 인증이 되었다.  
  
* 악의적인 유저는 CSRF 피해자가 악성 웹사이트를 방문하고 민감한 정보를 입력하도록 유도한다.  

* CSRF 피해자가 입력한 정보는 악의적인 유저의 계정이고, 그래서 악의적인 유저는  
  자신의 계정에 로그인해서 CSRF 피해자가 입력한 민감한 정보를 볼 수 있다.  
  
로그인 위조 CSRF 공격을 방어하기 위한 방법 중 하나는 유저가 session timeout 을 경험할 수 있는  
불편함이 있다. session timeout 은 로그인을 할 필요가 없을 줄 알았던 유저를 놀라게 한다.  
좀 더 자세한 정보는 [**CSRF and Session Timeouts**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-considerations-timeouts) 문서 를 참고하길 바란다.  
(아래에서 나온다.)

## Logging Out
로그아웃 위조 CSRF 공격을 방어하기 위해서, 로그아웃에 관한 HTTP Request 는 CSRF 공격에 대한  
방지책이 있어야한다. CSRF 피해자의 민감정보에 접근할 수 없도록 로그아웃 위조 CSRF 공격을 방어해야한다.  
[**이 블로그의 글**](https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/) 을 통해 자세한 내용을 살펴보길 바란다.

로그아웃 위조 CSRF 공격을 방어하기 위한 방법 중 하나는 유저가 session timeout 을 경험할 수 있는  
불편함이 있다. session timeout 은 로그아웃을 할 필요가 없을 줄 알았던 유저를 놀라게 한다.  
좀 더 자세한 정보는 [**CSRF and Session Timeouts**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-considerations-timeouts) 문서 를 참고하길 바란다.  
(아래에서 나온다.)
 
## CSRF and Session Timeouts
전달되길 기대되는 CSRF Token 은 session 에 저장되어있다.  
이것은 session 이 만료되면 서버는 CSRF Token 을 받지 못하고 HTTP Request 가 거부된다는 것을 의미한다.  
timeout 을 해결하기 위한 다양한 방법이 있고 각각 단장점이 있다.  

* timeout 을 완화하기 위한 가장 좋은 방법은 입력 폼을 제출 할 때 CSRF Token 을 요청하는 것 이다.
  폼은 CSRF Token 으로 업데이트 된 후 제출될 것 이다.
  
* 또 다른 방법은 유저에게 곧 session 만료될 것 이라고 알려주는  
  JavaScript 를 사용하는 것 이다. 유저는 세션 연장하기 버튼 등과 같은 버튼을  
  클릭해서 세션을 갱신한다.
  
* 마지막으로 전달되길 기대되는 CSRF Token 을 쿠키에 저장하는 것이다.  
  이는 session 보다 전달되길 기대되는 CSRF 토큰을 더 오래 지속할 수 있게 한다.  
  
## Multipart (file upload)
이건 [**이 링크**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-considerations-multipart) 를 참고하고 나중에 공부를 해보자.

# 11. Security HTTP Response Headers
_이 문서는 보안관련 HTTP Response Header 의 일반적인 주제만 다룬다.  
Servlet 혹은 WebFlux 기반의 어플리케이션의 보안관련 HTTP Response Header 의  
자세한 내용에 대해서는 아래의 링크를 참조하길 바란다._  

* [**Servlet 기반 어플리케이션**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-headers)

* [**WebFlux 기반 어플리케이션**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#webflux-headers)

웹 어플리케이션의 보안을 높이기 위한 다양한 HTTP Response Header 들이 있다.  
여기서는 Spring Security 가 지원하는 보안관련 HTTP Response Header 를 다룬다.  
필요하다면, [**Custom Header 들**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers-custom) 을 사용하도록 Spring Security 를 설정할 수 있다.  

## Default Security Headers
Spring Security 는 기본적으로 보안성을 제공하기 위해 기본 보안관련 HTTP Response Header 를 제공한다.  
아래의 Header 들은 Spring Security 가 기본적으로 제공하는 Header 들이다.  

* Default Security HTTP Response Headers  
```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

_Strict-Transport-Security Header 는 HTTPS Request 에 대해서만 추가된다._

이 기본설정들이 당신의 요구를 충족시키지 못한다면, 보안관련 HTTP Response Header 를 쉽게 제거하고
, 수정하고, 더하는 것이 가능하다. 이러한 각 헤더에 대한 자세한 내용은 아래의 섹션들을 통해  
다루고 있다.

* Cache Control  
* Content Type Options  
* HTTP Strict Transport Security  
* X-Frame-Options  
* X-XSS-Protection  

## Cache Control
_이 내용에 대한 커스텀 방법은 Servlet 의 경우 [**이 링크**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-headers-cache-control), WebFlux 의 경우 [**이 링크**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#webflux-headers-cache-control) 를 참조하길 바란다._  
Spring Security 는 기본적으로 유저의 컨텐츠를 캐싱하지 못하도록 설정해두었다.  

만약 유저가 민감한 정보를 보기위해 인증을 하고(로그인을 하고) 로그아웃을 했다면,  
우리는 악의적인 사용자가 뒤로가기 버튼을 통해 유저가 로그인하고 봤던 민감한 정보를 볼 수 없길 원한다.  
Cache Control Header 는 기본적으로 아래의 모양으로 전송된다.  

* Default Cache Control HTTP Response Headers
```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
```

이러한 상황을 기본적으로 보호하기 위해, Spring Security 는 기본적으로 이 Header 를 제공한다.  
하지만 만약 당신의 어플리케이션이 자신의 Cache Control Header 를 설정해서 사용하고 있다면,  
Spring Security 의 Cache Control Header 는 사라질 것 이다.
이를 통해 당신의 어플리케이션은 CSS 와 JavaScript 같은 정적 리소스를 캐싱할 수 있다.

## Content Type Options
_이 내용에 대한 커스텀 방법은 Servlet 의 경우 [**이 링크**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-headers-content-type-options) , WebFlux 의 경우 [**이 링크**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#webflux-headers-content-type-options) 를 참조하길 바란다._
인터넷 익스플로러를 포함해 전통적으로 브라우저들은 [**content sniffing**](https://en.wikipedia.org/wiki/Content_sniffing) 을 통해 content type 을  
추측해왔다. 이렇게 content sniffing 을 함으로써, 브라우저들은 content type 을 지정하지 않은  
리소스의 content type 을 추론하여 유저들의 경험을 개선할 수 있었다.    
예를들어 브라우저가 content type 을 지정하지 않은 JavaScript File 을 만났을 때,  
content sniffing 을 통해 content type 을 추론하고 이 JavaScript File 을 실행할 수 있다.  

content sniffing 의 문제점은 악의적인 사용자가 XSS 공격을 수행하기 위해  
정당한 멀티파트 content type 의 File 을 이용할 수 있다는 점 이다.  
예를들어 어떤 사이트들은 유저들이 유효한 postscript 문서를 제출할 수 있고,  
이를 볼 수 잇다고 가정해보자. 악의적인 유저들은 [**JavaScript 로 된 유효한 postscript 문서**](http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf) 를 만들고  
XSS 공격을 수행할 수 있다.

Spring Security 는 기본적으로 아래의 헤더를 사용해서 content sniffing 을 막고있다.  

*  nosniff HTTP Response Header
```
X-Content-Type-Options: nosniff
```

## HTTP Strict Transport Security (HSTS)
_이 내용에 대한 커스텀 방법은 Servlet 의 경우 [**이 링크**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-headers-hsts), WebFlux 의 경우 [**이 링크**](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#webflux-headers-hsts) 를 참조하길 바란다._
당신이 은행 웹사이트를 주소창에 입력할 때 mybank.example.com 이라고 입력하는가 아니면  
https://mybank.example.com 이라고 입력하는가?  
  
만약 mybank.example.com 과 같이 https 프로토콜을 생략하고 입력한다면,  
[**Man in the Middle attacks**](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) 에 잠재적인 위협을 받을 수 있다.  
설령 웹사이트가 https://mybank.example.com 으로 리다이렉트 시킨다고 해도 악의적인 사용자는  
처음 HTTP Request 를 가로채서 Response 를 조작하여 만들어 낼 수 있다.  
(https://mibank.example.com 과 같은 사이트로 리다이렉트 시키고 개인정보를 탈취해간다.)  

많은 유저들이 https 프로토콜을 생략한 채 사용하는데 그래서 [**HTTP Strict Transport Security (HSTS)**](https://tools.ietf.org/html/rfc6797) 가 만들어졌다.  
한번 [**HSTS host**](https://tools.ietf.org/html/rfc6797#section-5.1) 에 추가되면, 브라우저는 mybank.example.com 으로 요청하면  
https://mybank.example.com 으로 해석되야 함을 알 수 있다.  
이렇게되면 Man in the Middle attacks(중간자 공격) 의 가능성을 매우 낮출 수 있다.  

